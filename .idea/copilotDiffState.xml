<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mdavila_2001/mappyapp/ui/viewmodels/RoutesViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mdavila_2001/mappyapp/ui/viewmodels/RoutesViewModel.kt" />
              <option name="originalContent" value="package com.mdavila_2001.mappyapp.ui.viewmodels&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.mdavila_2001.mappyapp.data.remote.models.Route&#10;import com.mdavila_2001.mappyapp.data.repositories.RouteRepository&#10;import com.mdavila_2001.mappyapp.utils.SessionManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;enum class Tab {&#10;    ROUTES,&#10;    MY_ROUTES&#10;}&#10;&#10;data class RoutesUIState(&#10;    val isLoading: Boolean = true,&#10;    val selectedTab: Tab = Tab.ROUTES,&#10;    val list: List&lt;Route&gt; = emptyList(),&#10;    val searchText: String = &quot;&quot;,&#10;    val currentUsername: String = &quot;&quot;,&#10;)&#10;&#10;class RoutesViewModel(application: Application): AndroidViewModel(application) {&#10;    private val repository = RouteRepository()&#10;    private val sessionManager = SessionManager(application)&#10;&#10;    private val _uiState = MutableStateFlow(RoutesUIState())&#10;    val uiState: StateFlow&lt;RoutesUIState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _toastMessage = MutableStateFlow&lt;String?&gt;(null)&#10;    val toastMessage: StateFlow&lt;String?&gt; = _toastMessage.asStateFlow()&#10;&#10;    private val _navigateToLogin = MutableStateFlow(false)&#10;    val navigateToLogin: StateFlow&lt;Boolean&gt; = _navigateToLogin.asStateFlow()&#10;&#10;    val filteredRoutes: StateFlow&lt;List&lt;Route&gt;&gt; = _uiState&#10;        .map { state -&gt;&#10;            if (state.searchText.isBlank()) {&#10;                state.list&#10;            } else {&#10;                state.list.filter { route -&gt;&#10;                    route.name.contains(state.searchText, ignoreCase = true) ||&#10;                            route.username.contains(state.searchText, ignoreCase = true)&#10;                }&#10;            }&#10;        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())&#10;&#10;    init {&#10;        val loggedInUser = sessionManager.getUserName() ?: &quot;&quot;&#10;        _uiState.update { it.copy(currentUsername = loggedInUser) }&#10;&#10;        loadRoutes()&#10;    }&#10;&#10;    private fun loadRoutes() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;&#10;            val tab = _uiState.value.selectedTab&#10;            val routes = if (tab == Tab.ROUTES) {&#10;                repository.getAllRoutes()&#10;            } else {&#10;                repository.getRoutesByUser(uiState.value.currentUsername)&#10;            }&#10;            _uiState.update { it.copy(list = routes, isLoading = false) }&#10;        }&#10;    }&#10;&#10;    fun onTabSelected(tab: Tab) {&#10;        _uiState.update { it.copy(selectedTab = tab) }&#10;        loadRoutes()&#10;    }&#10;&#10;    fun onSearchTextChanged(text: String) {&#10;        _uiState.update { it.copy(searchText = text) }&#10;    }&#10;&#10;    fun deleteRoute(route: Route) {&#10;        viewModelScope.launch {&#10;            val success = repository.deleteRoute(route.id)&#10;            if(success) {&#10;                _uiState.update { currentState -&gt;&#10;                    currentState.copy(&#10;                        list = currentState.list.filterNot { it.id == route.id }&#10;                    )&#10;                }&#10;                // Recarga desde backend para asegurar consistencia y reflejar cambios de filtros&#10;                loadRoutes()&#10;                _toastMessage.value = &quot;Ruta eliminada correctamente&quot;&#10;            } else {&#10;                _toastMessage.value = &quot;Error al eliminar la ruta&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearToastMessage() {&#10;        _toastMessage.value = null&#10;    }&#10;&#10;    fun onNavigationDone() {&#10;        _navigateToLogin.value = false&#10;    }&#10;&#10;    fun onLogoutClicked() {&#10;        sessionManager.logout()&#10;        _navigateToLogin.value = true&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.mdavila_2001.mappyapp.ui.viewmodels&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.mdavila_2001.mappyapp.data.remote.models.Route&#10;import com.mdavila_2001.mappyapp.data.repositories.RouteRepository&#10;import com.mdavila_2001.mappyapp.utils.SessionManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;enum class Tab {&#10;    ROUTES,&#10;    MY_ROUTES&#10;}&#10;&#10;data class RoutesUIState(&#10;    val isLoading: Boolean = true,&#10;    val selectedTab: Tab = Tab.ROUTES,&#10;    val list: List&lt;Route&gt; = emptyList(),&#10;    val searchText: String = &quot;&quot;,&#10;    val currentUsername: String = &quot;&quot;,&#10;)&#10;&#10;class RoutesViewModel(application: Application): AndroidViewModel(application) {&#10;    private val repository = RouteRepository()&#10;    private val sessionManager = SessionManager(application)&#10;&#10;    private val _uiState = MutableStateFlow(RoutesUIState())&#10;    val uiState: StateFlow&lt;RoutesUIState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _toastMessage = MutableStateFlow&lt;String?&gt;(null)&#10;    val toastMessage: StateFlow&lt;String?&gt; = _toastMessage.asStateFlow()&#10;&#10;    private val _navigateToLogin = MutableStateFlow(false)&#10;    val navigateToLogin: StateFlow&lt;Boolean&gt; = _navigateToLogin.asStateFlow()&#10;&#10;    val filteredRoutes: StateFlow&lt;List&lt;Route&gt;&gt; = _uiState&#10;        .map { state -&gt;&#10;            if (state.searchText.isBlank()) {&#10;                state.list&#10;            } else {&#10;                state.list.filter { route -&gt;&#10;                    route.name.contains(state.searchText, ignoreCase = true) ||&#10;                            route.username.contains(state.searchText, ignoreCase = true)&#10;                }&#10;            }&#10;        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())&#10;&#10;    init {&#10;        val loggedInUser = sessionManager.getUserName() ?: &quot;&quot;&#10;        _uiState.update { it.copy(currentUsername = loggedInUser) }&#10;&#10;        loadRoutes()&#10;    }&#10;&#10;    private fun loadRoutes() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;&#10;            val tab = _uiState.value.selectedTab&#10;            val routes = if (tab == Tab.ROUTES) {&#10;                repository.getAllRoutes()&#10;            } else {&#10;                repository.getRoutesByUser(uiState.value.currentUsername)&#10;            }&#10;            _uiState.update { it.copy(list = routes, isLoading = false) }&#10;        }&#10;    }&#10;&#10;    fun onTabSelected(tab: Tab) {&#10;        _uiState.update { it.copy(selectedTab = tab) }&#10;        loadRoutes()&#10;    }&#10;&#10;    fun onSearchTextChanged(text: String) {&#10;        _uiState.update { it.copy(searchText = text) }&#10;    }&#10;&#10;    fun deleteRoute(route: Route) {&#10;        viewModelScope.launch {&#10;            val success = repository.deleteRoute(route.id)&#10;            if(success) {&#10;                _uiState.update { currentState -&gt;&#10;                    currentState.copy(&#10;                        list = currentState.list.filterNot { it.id == route.id }&#10;                    )&#10;                }&#10;                // Recarga desde backend para asegurar consistencia y reflejar cambios de filtros&#10;                loadRoutes()&#10;                _toastMessage.value = &quot;Ruta eliminada correctamente&quot;&#10;            } else {&#10;                _toastMessage.value = &quot;Error al eliminar la ruta&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearToastMessage() {&#10;        _toastMessage.value = null&#10;    }&#10;&#10;    fun onNavigationDone() {&#10;        _navigateToLogin.value = false&#10;    }&#10;&#10;    fun onLogoutClicked() {&#10;        sessionManager.logout()&#10;        _navigateToLogin.value = true&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mdavila_2001/mappyapp/ui/views/maps/MapRoutesScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mdavila_2001/mappyapp/ui/views/maps/MapRoutesScreen.kt" />
              <option name="originalContent" value="package com.mdavila_2001.mappyapp.ui.views.maps&#10;&#10;import android.Manifest&#10;import android.widget.Toast&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavController&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.MapsInitializer&#10;import com.google.android.gms.maps.model.CameraPosition&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.BitmapDescriptor&#10;import com.google.maps.android.compose.GoogleMap&#10;import com.google.maps.android.compose.MapProperties&#10;import com.google.maps.android.compose.Marker&#10;import com.google.maps.android.compose.MarkerState&#10;import com.google.maps.android.compose.rememberCameraPositionState&#10;import com.mdavila_2001.mappyapp.R&#10;import com.mdavila_2001.mappyapp.tools.Tools.bitmapDescriptorFromVector&#10;import com.mdavila_2001.mappyapp.ui.components.global.AppBar&#10;import com.mdavila_2001.mappyapp.ui.viewmodels.maps.MapRoutesViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MapRoutesScreen(&#10;    navController: NavController,&#10;    viewModel: MapRoutesViewModel = viewModel(),&#10;    routeId: Int,&#10;    routeName: String&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    var hasLocationPermission by remember { mutableStateOf(false) }&#10;&#10;    var customIcon by remember {&#10;        mutableStateOf&lt;BitmapDescriptor?&gt;(null)&#10;    }&#10;&#10;    var mapsInitialized by remember {&#10;        mutableStateOf(false)&#10;    }&#10;    &#10;    val requestPermissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { isGranted -&gt;&#10;            if (isGranted) {&#10;                hasLocationPermission = true&#10;            } else {&#10;                Toast.makeText(context, &quot;Permiso de ubicación negado&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    )&#10;    LaunchedEffect(Unit) {&#10;        try {&#10;            MapsInitializer.initialize(context)&#10;            mapsInitialized = true&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;&#10;        if (mapsInitialized) {&#10;            try {&#10;                customIcon = bitmapDescriptorFromVector(&#10;                    context,&#10;                    R.drawable.pin_point,&#10;                    width = 60,&#10;                    height = 60&#10;                )&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;&#10;        if (context.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) == android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;            hasLocationPermission = true&#10;        } else {&#10;            requestPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)&#10;        }&#10;&#10;        viewModel.loadLocations(routeId)&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            AppBar(&#10;                title = routeName,&#10;                logOutEnabled = false,&#10;                backEnabled = true,&#10;                onLogoutClick = {},&#10;                onBackClick = { navController.popBackStack() },&#10;                modifier = Modifier&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (uiState.isLoading) {&#10;                CircularProgressIndicator()&#10;            } else if (!hasLocationPermission) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxSize(),&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(&#10;                            R.drawable.no_map&#10;                        ),&#10;                        contentDescription = &quot;No hay mapa&quot;&#10;                    )&#10;                    Text(&quot;Se necesita permiso de ubicación para ver el mapa&quot;)&#10;                }&#10;            } else {&#10;                val mapPoints = uiState.locations.mapNotNull { location -&gt;&#10;                    val lat = location.latitude.toDouble()&#10;                    val lng = location.longitude.toDouble()&#10;                    if (lat != 0.0 &amp;&amp; lng != 0.0) {&#10;                        LatLng(lat,lng)&#10;                    } else {&#10;                        null&#10;                    }&#10;                }&#10;&#10;                val cameraPositionState = rememberCameraPositionState {&#10;                    position = CameraPosition.fromLatLngZoom(&#10;                        mapPoints.firstOrNull() ?: LatLng(-17.7833, -63.1833),&#10;                        15f&#10;                    )&#10;                }&#10;&#10;                LaunchedEffect(mapPoints) {&#10;                    if (mapPoints.isNotEmpty()) {&#10;                        if (mapsInitialized) {&#10;                            try {&#10;                                cameraPositionState.animate(&#10;                                    CameraUpdateFactory.newLatLngZoom(&#10;                                        mapPoints.first(),&#10;                                        15f&#10;                                    )&#10;                                )&#10;                            } catch (e: Exception) {&#10;                                e.printStackTrace()&#10;                                cameraPositionState.position = CameraPosition.fromLatLngZoom(mapPoints.first(), 15f)&#10;                            }&#10;                        } else {&#10;                            cameraPositionState.position = CameraPosition.fromLatLngZoom(mapPoints.first(), 15f)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                GoogleMap(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    cameraPositionState = cameraPositionState,&#10;                    properties = MapProperties(isMyLocationEnabled = true)&#10;                ) {&#10;                    mapPoints.forEach { point -&gt;&#10;                        Marker(&#10;                            state = MarkerState(position = point),&#10;                            title = &quot;Ubicación&quot;,&#10;                            icon = customIcon&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.mdavila_2001.mappyapp.ui.views.maps&#10;&#10;import android.Manifest&#10;import android.widget.Toast&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavController&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.MapsInitializer&#10;import com.google.android.gms.maps.model.CameraPosition&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.BitmapDescriptor&#10;import com.google.maps.android.compose.GoogleMap&#10;import com.google.maps.android.compose.MapProperties&#10;import com.google.maps.android.compose.Marker&#10;import com.google.maps.android.compose.MarkerState&#10;import com.google.maps.android.compose.rememberCameraPositionState&#10;import com.mdavila_2001.mappyapp.R&#10;import com.mdavila_2001.mappyapp.tools.Tools.bitmapDescriptorFromVector&#10;import com.mdavila_2001.mappyapp.ui.components.global.AppBar&#10;import com.mdavila_2001.mappyapp.ui.viewmodels.maps.MapRoutesViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MapRoutesScreen(&#10;    navController: NavController,&#10;    viewModel: MapRoutesViewModel = viewModel(),&#10;    routeId: Int,&#10;    routeName: String&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    var hasLocationPermission by remember { mutableStateOf(false) }&#10;&#10;    var customIcon by remember {&#10;        mutableStateOf&lt;BitmapDescriptor?&gt;(null)&#10;    }&#10;&#10;    var mapsInitialized by remember {&#10;        mutableStateOf(false)&#10;    }&#10;    &#10;    val requestPermissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { isGranted -&gt;&#10;            if (isGranted) {&#10;                hasLocationPermission = true&#10;            } else {&#10;                Toast.makeText(context, &quot;Permiso de ubicación negado&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    )&#10;    LaunchedEffect(Unit) {&#10;        try {&#10;            MapsInitializer.initialize(context)&#10;            mapsInitialized = true&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;&#10;        if (mapsInitialized) {&#10;            try {&#10;                customIcon = bitmapDescriptorFromVector(&#10;                    context,&#10;                    R.drawable.pin_point,&#10;                    width = 60,&#10;                    height = 60&#10;                )&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;&#10;        if (context.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) == android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;            hasLocationPermission = true&#10;        } else {&#10;            requestPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)&#10;        }&#10;&#10;        viewModel.loadLocations(routeId)&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            AppBar(&#10;                title = routeName,&#10;                logOutEnabled = false,&#10;                backEnabled = true,&#10;                onLogoutClick = {},&#10;                onBackClick = { navController.popBackStack() },&#10;                modifier = Modifier&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (uiState.isLoading) {&#10;                CircularProgressIndicator()&#10;            } else if (!hasLocationPermission) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxSize(),&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(&#10;                            R.drawable.no_map&#10;                        ),&#10;                        contentDescription = &quot;No hay mapa&quot;&#10;                    )&#10;                    Text(&quot;Se necesita permiso de ubicación para ver el mapa&quot;)&#10;                }&#10;            } else {&#10;                val mapPoints = uiState.locations.mapNotNull { location -&gt;&#10;                    val lat = location.latitude.toDouble()&#10;                    val lng = location.longitude.toDouble()&#10;                    if (lat != 0.0 &amp;&amp; lng != 0.0) {&#10;                        LatLng(lat,lng)&#10;                    } else {&#10;                        null&#10;                    }&#10;                }&#10;&#10;                val cameraPositionState = rememberCameraPositionState {&#10;                    position = CameraPosition.fromLatLngZoom(&#10;                        mapPoints.firstOrNull() ?: LatLng(-17.7833, -63.1833),&#10;                        15f&#10;                    )&#10;                }&#10;&#10;                LaunchedEffect(mapPoints) {&#10;                    if (mapPoints.isNotEmpty()) {&#10;                        if (mapsInitialized) {&#10;                            try {&#10;                                cameraPositionState.animate(&#10;                                    CameraUpdateFactory.newLatLngZoom(&#10;                                        mapPoints.first(),&#10;                                        15f&#10;                                    )&#10;                                )&#10;                            } catch (e: Exception) {&#10;                                e.printStackTrace()&#10;                                cameraPositionState.position = CameraPosition.fromLatLngZoom(mapPoints.first(), 15f)&#10;                            }&#10;                        } else {&#10;                            cameraPositionState.position = CameraPosition.fromLatLngZoom(mapPoints.first(), 15f)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                GoogleMap(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    cameraPositionState = cameraPositionState,&#10;                    properties = MapProperties(isMyLocationEnabled = true)&#10;                ) {&#10;                    mapPoints.forEach { point -&gt;&#10;                        Marker(&#10;                            state = MarkerState(position = point),&#10;                            title = &quot;Ubicación&quot;,&#10;                            icon = customIcon&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>